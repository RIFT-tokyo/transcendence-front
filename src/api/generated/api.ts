/* tslint:disable */
/* eslint-disable */
/**
 * transcendence API
 * The transendence API enables programmatic access to transcendence.
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Achievement
 */
export interface Achievement {
    /**
     * 
     * @type {number}
     * @memberof Achievement
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Achievement
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Achievement
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Achievement
     */
    'image'?: string;
    /**
     * 
     * @type {string}
     * @memberof Achievement
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Achievement
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface Channel
 */
export interface Channel {
    /**
     * 
     * @type {number}
     * @memberof Channel
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Channel
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Channel
     */
    'is_protected'?: boolean;
    /**
     * 
     * @type {Role}
     * @memberof Channel
     */
    'role'?: Role;
    /**
     * 
     * @type {string}
     * @memberof Channel
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Channel
     */
    'updated_at'?: string;
}
/**
 * 
 * @export
 * @interface ChannelPassword
 */
export interface ChannelPassword {
    /**
     * 
     * @type {string}
     * @memberof ChannelPassword
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface ChannelUser
 */
export interface ChannelUser {
    /**
     * 
     * @type {User}
     * @memberof ChannelUser
     */
    'user'?: User;
    /**
     * 
     * @type {Role}
     * @memberof ChannelUser
     */
    'role'?: Role;
}
/**
 * 
 * @export
 * @interface ChannelUserPermission
 */
export interface ChannelUserPermission {
    /**
     * 
     * @type {Role}
     * @memberof ChannelUserPermission
     */
    'role'?: Role;
    /**
     * 
     * @type {boolean}
     * @memberof ChannelUserPermission
     */
    'is_ban'?: boolean;
}
/**
 * 
 * @export
 * @interface FilePath
 */
export interface FilePath {
    /**
     * 
     * @type {string}
     * @memberof FilePath
     */
    'file_path'?: string;
}
/**
 * 
 * @export
 * @interface Login
 */
export interface Login {
    /**
     * 
     * @type {string}
     * @memberof Login
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof Login
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface Match
 */
export interface Match {
    /**
     * 
     * @type {number}
     * @memberof Match
     */
    'id'?: number;
    /**
     * 
     * @type {User}
     * @memberof Match
     */
    'host_player'?: User;
    /**
     * 
     * @type {User}
     * @memberof Match
     */
    'guest_player'?: User;
    /**
     * 
     * @type {number}
     * @memberof Match
     */
    'host_player_points'?: number;
    /**
     * 
     * @type {number}
     * @memberof Match
     */
    'guest_player_points'?: number;
    /**
     * 
     * @type {string}
     * @memberof Match
     */
    'result'?: MatchResultEnum;
    /**
     * 
     * @type {string}
     * @memberof Match
     */
    'start_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Match
     */
    'end_at'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum MatchResultEnum {
    Host = 'host',
    Guest = 'guest',
    Draw = 'draw'
}

/**
 * 
 * @export
 * @interface MatchList
 */
export interface MatchList {
    /**
     * 
     * @type {Array<Match>}
     * @memberof MatchList
     */
    'entries'?: Array<Match>;
    /**
     * 
     * @type {boolean}
     * @memberof MatchList
     */
    'has_next'?: boolean;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {number}
     * @memberof ModelError
     */
    'status_code'?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface NewChannel
 */
export interface NewChannel {
    /**
     * 
     * @type {string}
     * @memberof NewChannel
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof NewChannel
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface Password
 */
export interface Password {
    /**
     * 
     * @type {string}
     * @memberof Password
     */
    'old_password': string;
    /**
     * 
     * @type {string}
     * @memberof Password
     */
    'new_password': string;
}
/**
 * 
 * @export
 * @interface RankedUser
 */
export interface RankedUser {
    /**
     * 
     * @type {number}
     * @memberof RankedUser
     */
    'rank'?: number;
    /**
     * 
     * @type {User}
     * @memberof RankedUser
     */
    'user'?: User;
    /**
     * 
     * @type {number}
     * @memberof RankedUser
     */
    'wins'?: number;
    /**
     * 
     * @type {number}
     * @memberof RankedUser
     */
    'loss'?: number;
}
/**
 * 
 * @export
 * @interface Role
 */
export interface Role {
    /**
     * 
     * @type {number}
     * @memberof Role
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * Unique identifier for the given user.
     * @type {number}
     * @memberof User
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'display_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'profile_image'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'status'?: UserStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'status_message'?: string;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'followers'?: number;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'following'?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'updated_at'?: string;
    /**
     * 
     * @type {Array<Achievement>}
     * @memberof User
     */
    'achievements'?: Array<Achievement>;
}

/**
    * @export
    * @enum {string}
    */
export enum UserStatusEnum {
    Online = 'online',
    Offline = 'offline',
    Game = 'game'
}

/**
 * 
 * @export
 * @interface UserList
 */
export interface UserList {
    /**
     * 
     * @type {Array<User>}
     * @memberof UserList
     */
    'entries'?: Array<User>;
    /**
     * 
     * @type {boolean}
     * @memberof UserList
     */
    'has_next'?: boolean;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * After allowing transcendence on screen 42, you will be redirected here. This is where the server-side will register or retrieve the user\'s information.
         * @summary Oauth callback
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthCallback: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/callback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The first client request by 42 for oauth2.0. After this, you will be redirected to 42\'s confirm browser.
         * @summary Login with 42 intra account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthLogin: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * username and password auth without using auth.
         * @summary Login with username and password
         * @param {Login} [login] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthLogin: async (login?: Login, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(login, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * logout from transcendence
         * @summary Logout from transcendence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthLogout: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new user
         * @param {Login} [login] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthSignup: async (login?: Login, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/signup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(login, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update User Password
         * @param {Password} [password] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAuthPassword: async (password?: Password, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(password, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * After allowing transcendence on screen 42, you will be redirected here. This is where the server-side will register or retrieve the user\'s information.
         * @summary Oauth callback
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthCallback(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthCallback(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The first client request by 42 for oauth2.0. After this, you will be redirected to 42\'s confirm browser.
         * @summary Login with 42 intra account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthLogin(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthLogin(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * username and password auth without using auth.
         * @summary Login with username and password
         * @param {Login} [login] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAuthLogin(login?: Login, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postAuthLogin(login, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * logout from transcendence
         * @summary Logout from transcendence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAuthLogout(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postAuthLogout(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create new user
         * @param {Login} [login] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAuthSignup(login?: Login, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postAuthSignup(login, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update User Password
         * @param {Password} [password] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putAuthPassword(password?: Password, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putAuthPassword(password, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * After allowing transcendence on screen 42, you will be redirected here. This is where the server-side will register or retrieve the user\'s information.
         * @summary Oauth callback
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthCallback(options?: any): AxiosPromise<void> {
            return localVarFp.getAuthCallback(options).then((request) => request(axios, basePath));
        },
        /**
         * The first client request by 42 for oauth2.0. After this, you will be redirected to 42\'s confirm browser.
         * @summary Login with 42 intra account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthLogin(options?: any): AxiosPromise<void> {
            return localVarFp.getAuthLogin(options).then((request) => request(axios, basePath));
        },
        /**
         * username and password auth without using auth.
         * @summary Login with username and password
         * @param {Login} [login] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthLogin(login?: Login, options?: any): AxiosPromise<void> {
            return localVarFp.postAuthLogin(login, options).then((request) => request(axios, basePath));
        },
        /**
         * logout from transcendence
         * @summary Logout from transcendence
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthLogout(options?: any): AxiosPromise<void> {
            return localVarFp.postAuthLogout(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create new user
         * @param {Login} [login] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAuthSignup(login?: Login, options?: any): AxiosPromise<void> {
            return localVarFp.postAuthSignup(login, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update User Password
         * @param {Password} [password] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAuthPassword(password?: Password, options?: any): AxiosPromise<void> {
            return localVarFp.putAuthPassword(password, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - interface
 * @export
 * @interface AuthApi
 */
export interface AuthApiInterface {
    /**
     * After allowing transcendence on screen 42, you will be redirected here. This is where the server-side will register or retrieve the user\'s information.
     * @summary Oauth callback
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    getAuthCallback(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * The first client request by 42 for oauth2.0. After this, you will be redirected to 42\'s confirm browser.
     * @summary Login with 42 intra account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    getAuthLogin(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * username and password auth without using auth.
     * @summary Login with username and password
     * @param {Login} [login] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    postAuthLogin(login?: Login, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * logout from transcendence
     * @summary Logout from transcendence
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    postAuthLogout(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Create new user
     * @param {Login} [login] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    postAuthSignup(login?: Login, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Update User Password
     * @param {Password} [password] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApiInterface
     */
    putAuthPassword(password?: Password, options?: AxiosRequestConfig): AxiosPromise<void>;

}

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI implements AuthApiInterface {
    /**
     * After allowing transcendence on screen 42, you will be redirected here. This is where the server-side will register or retrieve the user\'s information.
     * @summary Oauth callback
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getAuthCallback(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).getAuthCallback(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The first client request by 42 for oauth2.0. After this, you will be redirected to 42\'s confirm browser.
     * @summary Login with 42 intra account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getAuthLogin(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).getAuthLogin(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * username and password auth without using auth.
     * @summary Login with username and password
     * @param {Login} [login] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public postAuthLogin(login?: Login, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).postAuthLogin(login, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * logout from transcendence
     * @summary Logout from transcendence
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public postAuthLogout(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).postAuthLogout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create new user
     * @param {Login} [login] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public postAuthSignup(login?: Login, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).postAuthSignup(login, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update User Password
     * @param {Password} [password] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public putAuthPassword(password?: Password, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).putAuthPassword(password, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ChannelApi - axios parameter creator
 * @export
 */
export const ChannelApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Leave channel
         * @param {number} channelID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMeChannelsChannelId: async (channelID: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelID' is not null or undefined
            assertParamExists('deleteMeChannelsChannelId', 'channelID', channelID)
            const localVarPath = `/me/channels/{channelID}`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List channels
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannels: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/channels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List channels in which the authenticated user participates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelsMe: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/me/channels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List users participating in a channel
         * @param {number} channelID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelsUsersUserID: async (channelID: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelID' is not null or undefined
            assertParamExists('getChannelsUsersUserID', 'channelID', channelID)
            const localVarPath = `/channels/{channelID}/users`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create new channel
         * @param {NewChannel} [newChannel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postChannels: async (newChannel?: NewChannel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/channels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newChannel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a channel
         * @param {number} channelID 
         * @param {NewChannel} [newChannel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putChannelsChannelID: async (channelID: number, newChannel?: NewChannel, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelID' is not null or undefined
            assertParamExists('putChannelsChannelID', 'channelID', channelID)
            const localVarPath = `/channels/{channelID}`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newChannel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the status of user participating in the channel
         * @param {number} channelID 
         * @param {number} userID 
         * @param {ChannelUserPermission} [channelUserPermission] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putChannelsChannelIDUsersUserID: async (channelID: number, userID: number, channelUserPermission?: ChannelUserPermission, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelID' is not null or undefined
            assertParamExists('putChannelsChannelIDUsersUserID', 'channelID', channelID)
            // verify required parameter 'userID' is not null or undefined
            assertParamExists('putChannelsChannelIDUsersUserID', 'userID', userID)
            const localVarPath = `/users/{userID}/channels/{channelID}`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)))
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(channelUserPermission, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Join channel
         * @param {number} channelID 
         * @param {ChannelPassword} [channelPassword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putMeChannelsChannelId: async (channelID: number, channelPassword?: ChannelPassword, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelID' is not null or undefined
            assertParamExists('putMeChannelsChannelId', 'channelID', channelID)
            const localVarPath = `/me/channels/{channelID}`
                .replace(`{${"channelID"}}`, encodeURIComponent(String(channelID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(channelPassword, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChannelApi - functional programming interface
 * @export
 */
export const ChannelApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChannelApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Leave channel
         * @param {number} channelID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMeChannelsChannelId(channelID: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMeChannelsChannelId(channelID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List channels
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannels(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Channel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChannels(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List channels in which the authenticated user participates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannelsMe(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Channel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChannelsMe(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List users participating in a channel
         * @param {number} channelID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChannelsUsersUserID(channelID: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ChannelUser>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChannelsUsersUserID(channelID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create new channel
         * @param {NewChannel} [newChannel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postChannels(newChannel?: NewChannel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Channel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postChannels(newChannel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a channel
         * @param {number} channelID 
         * @param {NewChannel} [newChannel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putChannelsChannelID(channelID: number, newChannel?: NewChannel, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putChannelsChannelID(channelID, newChannel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the status of user participating in the channel
         * @param {number} channelID 
         * @param {number} userID 
         * @param {ChannelUserPermission} [channelUserPermission] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putChannelsChannelIDUsersUserID(channelID: number, userID: number, channelUserPermission?: ChannelUserPermission, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChannelUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putChannelsChannelIDUsersUserID(channelID, userID, channelUserPermission, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Join channel
         * @param {number} channelID 
         * @param {ChannelPassword} [channelPassword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putMeChannelsChannelId(channelID: number, channelPassword?: ChannelPassword, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Channel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putMeChannelsChannelId(channelID, channelPassword, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ChannelApi - factory interface
 * @export
 */
export const ChannelApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChannelApiFp(configuration)
    return {
        /**
         * 
         * @summary Leave channel
         * @param {number} channelID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMeChannelsChannelId(channelID: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteMeChannelsChannelId(channelID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List channels
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannels(options?: any): AxiosPromise<Array<Channel>> {
            return localVarFp.getChannels(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List channels in which the authenticated user participates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelsMe(options?: any): AxiosPromise<Array<Channel>> {
            return localVarFp.getChannelsMe(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List users participating in a channel
         * @param {number} channelID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChannelsUsersUserID(channelID: number, options?: any): AxiosPromise<Array<ChannelUser>> {
            return localVarFp.getChannelsUsersUserID(channelID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create new channel
         * @param {NewChannel} [newChannel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postChannels(newChannel?: NewChannel, options?: any): AxiosPromise<Channel> {
            return localVarFp.postChannels(newChannel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a channel
         * @param {number} channelID 
         * @param {NewChannel} [newChannel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putChannelsChannelID(channelID: number, newChannel?: NewChannel, options?: any): AxiosPromise<void> {
            return localVarFp.putChannelsChannelID(channelID, newChannel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the status of user participating in the channel
         * @param {number} channelID 
         * @param {number} userID 
         * @param {ChannelUserPermission} [channelUserPermission] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putChannelsChannelIDUsersUserID(channelID: number, userID: number, channelUserPermission?: ChannelUserPermission, options?: any): AxiosPromise<ChannelUser> {
            return localVarFp.putChannelsChannelIDUsersUserID(channelID, userID, channelUserPermission, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Join channel
         * @param {number} channelID 
         * @param {ChannelPassword} [channelPassword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putMeChannelsChannelId(channelID: number, channelPassword?: ChannelPassword, options?: any): AxiosPromise<Channel> {
            return localVarFp.putMeChannelsChannelId(channelID, channelPassword, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChannelApi - interface
 * @export
 * @interface ChannelApi
 */
export interface ChannelApiInterface {
    /**
     * 
     * @summary Leave channel
     * @param {number} channelID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApiInterface
     */
    deleteMeChannelsChannelId(channelID: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary List channels
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApiInterface
     */
    getChannels(options?: AxiosRequestConfig): AxiosPromise<Array<Channel>>;

    /**
     * 
     * @summary List channels in which the authenticated user participates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApiInterface
     */
    getChannelsMe(options?: AxiosRequestConfig): AxiosPromise<Array<Channel>>;

    /**
     * 
     * @summary List users participating in a channel
     * @param {number} channelID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApiInterface
     */
    getChannelsUsersUserID(channelID: number, options?: AxiosRequestConfig): AxiosPromise<Array<ChannelUser>>;

    /**
     * 
     * @summary Create new channel
     * @param {NewChannel} [newChannel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApiInterface
     */
    postChannels(newChannel?: NewChannel, options?: AxiosRequestConfig): AxiosPromise<Channel>;

    /**
     * 
     * @summary Update a channel
     * @param {number} channelID 
     * @param {NewChannel} [newChannel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApiInterface
     */
    putChannelsChannelID(channelID: number, newChannel?: NewChannel, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Update the status of user participating in the channel
     * @param {number} channelID 
     * @param {number} userID 
     * @param {ChannelUserPermission} [channelUserPermission] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApiInterface
     */
    putChannelsChannelIDUsersUserID(channelID: number, userID: number, channelUserPermission?: ChannelUserPermission, options?: AxiosRequestConfig): AxiosPromise<ChannelUser>;

    /**
     * 
     * @summary Join channel
     * @param {number} channelID 
     * @param {ChannelPassword} [channelPassword] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApiInterface
     */
    putMeChannelsChannelId(channelID: number, channelPassword?: ChannelPassword, options?: AxiosRequestConfig): AxiosPromise<Channel>;

}

/**
 * ChannelApi - object-oriented interface
 * @export
 * @class ChannelApi
 * @extends {BaseAPI}
 */
export class ChannelApi extends BaseAPI implements ChannelApiInterface {
    /**
     * 
     * @summary Leave channel
     * @param {number} channelID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    public deleteMeChannelsChannelId(channelID: number, options?: AxiosRequestConfig) {
        return ChannelApiFp(this.configuration).deleteMeChannelsChannelId(channelID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List channels
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    public getChannels(options?: AxiosRequestConfig) {
        return ChannelApiFp(this.configuration).getChannels(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List channels in which the authenticated user participates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    public getChannelsMe(options?: AxiosRequestConfig) {
        return ChannelApiFp(this.configuration).getChannelsMe(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List users participating in a channel
     * @param {number} channelID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    public getChannelsUsersUserID(channelID: number, options?: AxiosRequestConfig) {
        return ChannelApiFp(this.configuration).getChannelsUsersUserID(channelID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create new channel
     * @param {NewChannel} [newChannel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    public postChannels(newChannel?: NewChannel, options?: AxiosRequestConfig) {
        return ChannelApiFp(this.configuration).postChannels(newChannel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a channel
     * @param {number} channelID 
     * @param {NewChannel} [newChannel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    public putChannelsChannelID(channelID: number, newChannel?: NewChannel, options?: AxiosRequestConfig) {
        return ChannelApiFp(this.configuration).putChannelsChannelID(channelID, newChannel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the status of user participating in the channel
     * @param {number} channelID 
     * @param {number} userID 
     * @param {ChannelUserPermission} [channelUserPermission] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    public putChannelsChannelIDUsersUserID(channelID: number, userID: number, channelUserPermission?: ChannelUserPermission, options?: AxiosRequestConfig) {
        return ChannelApiFp(this.configuration).putChannelsChannelIDUsersUserID(channelID, userID, channelUserPermission, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Join channel
     * @param {number} channelID 
     * @param {ChannelPassword} [channelPassword] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    public putMeChannelsChannelId(channelID: number, channelPassword?: ChannelPassword, options?: AxiosRequestConfig) {
        return ChannelApiFp(this.configuration).putMeChannelsChannelId(channelID, channelPassword, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FollowApi - axios parameter creator
 * @export
 */
export const FollowApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Unfollow a user
         * @param {number} userID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsersFollowingUserID: async (userID: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userID' is not null or undefined
            assertParamExists('deleteUsersFollowingUserID', 'userID', userID)
            const localVarPath = `/users/following/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the people who the specified user follows.
         * @summary List the people a user follows
         * @param {number} userID 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUserIDFollowing: async (userID: number, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userID' is not null or undefined
            assertParamExists('getUsersUserIDFollowing', 'userID', userID)
            const localVarPath = `/users/{userID}/following`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check if a user follows another user
         * @param {number} userID 
         * @param {number} targetUserID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUserIDFollowingTargetUserID: async (userID: number, targetUserID: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userID' is not null or undefined
            assertParamExists('getUsersUserIDFollowingTargetUserID', 'userID', userID)
            // verify required parameter 'targetUserID' is not null or undefined
            assertParamExists('getUsersUserIDFollowingTargetUserID', 'targetUserID', targetUserID)
            const localVarPath = `/users/{userID}/following/{targetUserID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)))
                .replace(`{${"targetUserID"}}`, encodeURIComponent(String(targetUserID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists the people following the specified user.
         * @summary List Followers of a user
         * @param {number} userID 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUserIdFriends: async (userID: number, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userID' is not null or undefined
            assertParamExists('getUsersUserIdFriends', 'userID', userID)
            const localVarPath = `/users/{userID}/followers`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Follow a user
         * @param {number} userID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUsersFollowingUserID: async (userID: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userID' is not null or undefined
            assertParamExists('putUsersFollowingUserID', 'userID', userID)
            const localVarPath = `/users/following/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FollowApi - functional programming interface
 * @export
 */
export const FollowApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FollowApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Unfollow a user
         * @param {number} userID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUsersFollowingUserID(userID: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUsersFollowingUserID(userID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists the people who the specified user follows.
         * @summary List the people a user follows
         * @param {number} userID 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersUserIDFollowing(userID: number, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersUserIDFollowing(userID, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Check if a user follows another user
         * @param {number} userID 
         * @param {number} targetUserID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersUserIDFollowingTargetUserID(userID: number, targetUserID: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersUserIDFollowingTargetUserID(userID, targetUserID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists the people following the specified user.
         * @summary List Followers of a user
         * @param {number} userID 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersUserIdFriends(userID: number, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersUserIdFriends(userID, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Follow a user
         * @param {number} userID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putUsersFollowingUserID(userID: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putUsersFollowingUserID(userID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FollowApi - factory interface
 * @export
 */
export const FollowApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FollowApiFp(configuration)
    return {
        /**
         * 
         * @summary Unfollow a user
         * @param {number} userID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsersFollowingUserID(userID: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUsersFollowingUserID(userID, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists the people who the specified user follows.
         * @summary List the people a user follows
         * @param {number} userID 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUserIDFollowing(userID: number, limit?: number, offset?: number, options?: any): AxiosPromise<UserList> {
            return localVarFp.getUsersUserIDFollowing(userID, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check if a user follows another user
         * @param {number} userID 
         * @param {number} targetUserID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUserIDFollowingTargetUserID(userID: number, targetUserID: number, options?: any): AxiosPromise<void> {
            return localVarFp.getUsersUserIDFollowingTargetUserID(userID, targetUserID, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists the people following the specified user.
         * @summary List Followers of a user
         * @param {number} userID 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUserIdFriends(userID: number, limit?: number, offset?: number, options?: any): AxiosPromise<UserList> {
            return localVarFp.getUsersUserIdFriends(userID, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Follow a user
         * @param {number} userID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUsersFollowingUserID(userID: number, options?: any): AxiosPromise<void> {
            return localVarFp.putUsersFollowingUserID(userID, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FollowApi - interface
 * @export
 * @interface FollowApi
 */
export interface FollowApiInterface {
    /**
     * 
     * @summary Unfollow a user
     * @param {number} userID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FollowApiInterface
     */
    deleteUsersFollowingUserID(userID: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Lists the people who the specified user follows.
     * @summary List the people a user follows
     * @param {number} userID 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FollowApiInterface
     */
    getUsersUserIDFollowing(userID: number, limit?: number, offset?: number, options?: AxiosRequestConfig): AxiosPromise<UserList>;

    /**
     * 
     * @summary Check if a user follows another user
     * @param {number} userID 
     * @param {number} targetUserID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FollowApiInterface
     */
    getUsersUserIDFollowingTargetUserID(userID: number, targetUserID: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Lists the people following the specified user.
     * @summary List Followers of a user
     * @param {number} userID 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FollowApiInterface
     */
    getUsersUserIdFriends(userID: number, limit?: number, offset?: number, options?: AxiosRequestConfig): AxiosPromise<UserList>;

    /**
     * 
     * @summary Follow a user
     * @param {number} userID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FollowApiInterface
     */
    putUsersFollowingUserID(userID: number, options?: AxiosRequestConfig): AxiosPromise<void>;

}

/**
 * FollowApi - object-oriented interface
 * @export
 * @class FollowApi
 * @extends {BaseAPI}
 */
export class FollowApi extends BaseAPI implements FollowApiInterface {
    /**
     * 
     * @summary Unfollow a user
     * @param {number} userID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FollowApi
     */
    public deleteUsersFollowingUserID(userID: number, options?: AxiosRequestConfig) {
        return FollowApiFp(this.configuration).deleteUsersFollowingUserID(userID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the people who the specified user follows.
     * @summary List the people a user follows
     * @param {number} userID 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FollowApi
     */
    public getUsersUserIDFollowing(userID: number, limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return FollowApiFp(this.configuration).getUsersUserIDFollowing(userID, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check if a user follows another user
     * @param {number} userID 
     * @param {number} targetUserID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FollowApi
     */
    public getUsersUserIDFollowingTargetUserID(userID: number, targetUserID: number, options?: AxiosRequestConfig) {
        return FollowApiFp(this.configuration).getUsersUserIDFollowingTargetUserID(userID, targetUserID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists the people following the specified user.
     * @summary List Followers of a user
     * @param {number} userID 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FollowApi
     */
    public getUsersUserIdFriends(userID: number, limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return FollowApiFp(this.configuration).getUsersUserIdFriends(userID, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Follow a user
     * @param {number} userID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FollowApi
     */
    public putUsersFollowingUserID(userID: number, options?: AxiosRequestConfig) {
        return FollowApiFp(this.configuration).putUsersFollowingUserID(userID, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MatchApi - axios parameter creator
 * @export
 */
export const MatchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Your GET endpoint
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMatches: async (limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/matches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MatchApi - functional programming interface
 * @export
 */
export const MatchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MatchApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Your GET endpoint
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMatches(limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MatchList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMatches(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MatchApi - factory interface
 * @export
 */
export const MatchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MatchApiFp(configuration)
    return {
        /**
         * 
         * @summary Your GET endpoint
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMatches(limit?: number, offset?: number, options?: any): AxiosPromise<MatchList> {
            return localVarFp.getMatches(limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MatchApi - interface
 * @export
 * @interface MatchApi
 */
export interface MatchApiInterface {
    /**
     * 
     * @summary Your GET endpoint
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchApiInterface
     */
    getMatches(limit?: number, offset?: number, options?: AxiosRequestConfig): AxiosPromise<MatchList>;

}

/**
 * MatchApi - object-oriented interface
 * @export
 * @class MatchApi
 * @extends {BaseAPI}
 */
export class MatchApi extends BaseAPI implements MatchApiInterface {
    /**
     * 
     * @summary Your GET endpoint
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchApi
     */
    public getMatches(limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return MatchApiFp(this.configuration).getMatches(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a user profile image
         * @param {number} userID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsersUserIDImages: async (userID: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userID' is not null or undefined
            assertParamExists('deleteUsersUserIDImages', 'userID', userID)
            const localVarPath = `/users/{userID}/images`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a user
         * @param {number} userID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsersUserId: async (userID: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userID' is not null or undefined
            assertParamExists('deleteUsersUserId', 'userID', userID)
            const localVarPath = `/users/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the information of the user with the matching user ID.
         * @summary Get the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List users
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the information of the user with the matching user ID.
         * @summary Get a user
         * @param {number} userID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUserId: async (userID: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userID' is not null or undefined
            assertParamExists('getUsersUserId', 'userID', userID)
            const localVarPath = `/users/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a user by username
         * @param {string} username Username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUsername: async (username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('getUsersUsername', 'username', username)
            const localVarPath = `/users/by/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload a user profile image
         * @param {number} userID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersUserIDImages: async (userID: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userID' is not null or undefined
            assertParamExists('postUsersUserIDImages', 'userID', userID)
            const localVarPath = `/users/{userID}/images`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a user
         * @param {number} userID 
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUsersUserId: async (userID: number, user?: User, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userID' is not null or undefined
            assertParamExists('putUsersUserId', 'userID', userID)
            const localVarPath = `/users/{userID}`
                .replace(`{${"userID"}}`, encodeURIComponent(String(userID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication sessionAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete a user profile image
         * @param {number} userID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUsersUserIDImages(userID: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUsersUserIDImages(userID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a user
         * @param {number} userID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUsersUserId(userID: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUsersUserId(userID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve the information of the user with the matching user ID.
         * @summary Get the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMe(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMe(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List users
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve the information of the user with the matching user ID.
         * @summary Get a user
         * @param {number} userID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersUserId(userID: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersUserId(userID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a user by username
         * @param {string} username Username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersUsername(username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersUsername(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Upload a user profile image
         * @param {number} userID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUsersUserIDImages(userID: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilePath>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUsersUserIDImages(userID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a user
         * @param {number} userID 
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putUsersUserId(userID: number, user?: User, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putUsersUserId(userID, user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete a user profile image
         * @param {number} userID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsersUserIDImages(userID: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUsersUserIDImages(userID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a user
         * @param {number} userID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsersUserId(userID: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUsersUserId(userID, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the information of the user with the matching user ID.
         * @summary Get the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe(options?: any): AxiosPromise<User> {
            return localVarFp.getMe(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List users
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(limit?: number, offset?: number, options?: any): AxiosPromise<UserList> {
            return localVarFp.getUsers(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the information of the user with the matching user ID.
         * @summary Get a user
         * @param {number} userID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUserId(userID: number, options?: any): AxiosPromise<User> {
            return localVarFp.getUsersUserId(userID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a user by username
         * @param {string} username Username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUsername(username: string, options?: any): AxiosPromise<User> {
            return localVarFp.getUsersUsername(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload a user profile image
         * @param {number} userID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersUserIDImages(userID: number, options?: any): AxiosPromise<FilePath> {
            return localVarFp.postUsersUserIDImages(userID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a user
         * @param {number} userID 
         * @param {User} [user] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putUsersUserId(userID: number, user?: User, options?: any): AxiosPromise<User> {
            return localVarFp.putUsersUserId(userID, user, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - interface
 * @export
 * @interface UserApi
 */
export interface UserApiInterface {
    /**
     * 
     * @summary Delete a user profile image
     * @param {number} userID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    deleteUsersUserIDImages(userID: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete a user
     * @param {number} userID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    deleteUsersUserId(userID: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Retrieve the information of the user with the matching user ID.
     * @summary Get the authenticated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    getMe(options?: AxiosRequestConfig): AxiosPromise<User>;

    /**
     * 
     * @summary List users
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    getUsers(limit?: number, offset?: number, options?: AxiosRequestConfig): AxiosPromise<UserList>;

    /**
     * Retrieve the information of the user with the matching user ID.
     * @summary Get a user
     * @param {number} userID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    getUsersUserId(userID: number, options?: AxiosRequestConfig): AxiosPromise<User>;

    /**
     * 
     * @summary Get a user by username
     * @param {string} username Username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    getUsersUsername(username: string, options?: AxiosRequestConfig): AxiosPromise<User>;

    /**
     * 
     * @summary Upload a user profile image
     * @param {number} userID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    postUsersUserIDImages(userID: number, options?: AxiosRequestConfig): AxiosPromise<FilePath>;

    /**
     * 
     * @summary Update a user
     * @param {number} userID 
     * @param {User} [user] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    putUsersUserId(userID: number, user?: User, options?: AxiosRequestConfig): AxiosPromise<User>;

}

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI implements UserApiInterface {
    /**
     * 
     * @summary Delete a user profile image
     * @param {number} userID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteUsersUserIDImages(userID: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).deleteUsersUserIDImages(userID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a user
     * @param {number} userID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteUsersUserId(userID: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).deleteUsersUserId(userID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the information of the user with the matching user ID.
     * @summary Get the authenticated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getMe(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getMe(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List users
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUsers(limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUsers(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the information of the user with the matching user ID.
     * @summary Get a user
     * @param {number} userID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUsersUserId(userID: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUsersUserId(userID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a user by username
     * @param {string} username Username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUsersUsername(username: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUsersUsername(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload a user profile image
     * @param {number} userID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public postUsersUserIDImages(userID: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).postUsersUserIDImages(userID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a user
     * @param {number} userID 
     * @param {User} [user] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public putUsersUserId(userID: number, user?: User, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).putUsersUserId(userID, user, options).then((request) => request(this.axios, this.basePath));
    }
}


